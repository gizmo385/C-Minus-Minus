(ns cmm.mips
  "This namespace handles the generation of MIPS code based on the Three Address Codes generated by
   the functions in cmm.three."
  (:require [cmm.errors :as err]
            [cmm.debug :refer [debug-msg]]
            [clojure.string :refer [join]]))

;;; Utility functions
(defn- protected-name
  "Prepends an underscore to a var name to prevent MIPS errors"
  [s]
  (format "_%s" s))

;;; Automatically generated MIPs code
(def print-string-fn
  "A MIPS function to print character arrays."
  (->> ["_print_string:"
        "\tli $v0, 4"
        "\tlw $a0, 0($sp)"
        "\tsyscall"
        "\tjr $ra\n\n"]
       (join \newline)))

(def print-int-fn
  "A mips function to print an integer"
  (->> ["_print_int:"
        "\tli $v0, 1"
        "\tlw $a0, 0 ($sp)"
        "\tsyscall"
        "\tjr $ra\n\n"]
       (join \newline)))

;;; Function generation
(defn- function-prologue
  "Generates the prologue for a function with a specific name that requires a particular number of
   bytes on the stack."
  [function-name required-stack-space]
  (as-> [".text"
         "%s:"
         "\t# Prologue for %s"
         "\tla $sp, -8($sp) # Allocate space for old $fp and $ra"
         "\tsw $fp, 4($sp) # Save old frame pointer"
         "\tsw $ra, 0($sp) # Save old return address"
         "\tla $fp, 0($sp) # Set up the new frame pointer"
         "\tla $sp, %d($sp) # Allocate space for local variables and temps"
         "\n"]
    code
    (join \newline code)
    (format code function-name function-name required-stack-space)))

(defn- function-epilogue
  "Generates the MIPS function epilogue for a function of a particular name."
  [function-name]
  (as-> [""
         "%s_epilogue:"
         "\t# Epilogue for %s"
         "\tla $sp, 0($fp)"
         "\tlw $ra, 0($sp)"
         "\tlw $fp, 4($sp)"
         "\tla $sp, 8($sp)"
         "\tjr $ra\n\n"]
    code
    (join \newline code)
    (format code function-name function-name)))

;;; Loading and storing
(def type-loading
  {:char "lb"
   :int "lw"
   :float "lw"})


(def type-storing
  {:char "sb"
   :int "sw"
   :float "sw"})


;;; TODO: Handle storing/loading globals

(defn register->variable
  "Generates MIPS code to move a value from a register into a variable's storage location."
  [src-register {:keys [symbol-type offset] :as dest-var}]
  (format "\t%s, %s, %d($fp)\n" (type-storing symbol-type) src-register offset)
  )


(defn variable->register
  "Generates MIPS code to move a value from a variable's storage location into a register."
  [{:keys [array symbol-type symbol-name offset] :as src-var} dest-register]
  (if array
    (format "la %s, %s" dest-register (protected-name symbol-name))
    (format "%s %s, %d($fp)" (type-loading symbol-type) dest-register offset)))


(defn constant->register
  "Places a constant value into a register."
  [value dest-register]
  (condp instance? value
    Long      (format "\tli %s, %d\n" dest-register value)
    Character (format "\tli %s, %d\n" dest-register value)
    Double    (format "\tli.f %s, %d\n" dest-register value)))

;;; Translation from Three Address Codes to MIPS
(defmulti tac->mips
  "Primary translation function between three address code and MIPS assembly."
  (fn [{:keys [vars mips] :as result} tac]
    (:operation tac)))

(defmethod tac->mips :default
  [{:keys [errors] :or {errors []} :as result} {:keys [operation]}]
  (assoc result :errors (conj errors (format "Error: %s is not a recognized TAC." operation))))

(defmethod tac->mips nil
  [{:keys [errors] :or {errors []} :as result} tac]
  (assoc result :errors (conj errors (format "Error: Could not generate MIPS for %s." tac))))

(defmethod tac->mips :label
 [{:keys [vars mips] :as result} tac]
 (let [instruction (format "%s:" (protected-name (:destination tac)))]
   (assoc result :mips (conj mips instruction))))

(defmethod tac->mips :assg-literal
  [{:keys [vars mips] :as result} tac]
  ;; TODO: Load literal into register, register into variable
  )

;;; Functions to break down the TAC structure and properly format the output
(defn- handle-function-code
  "This generates the MIPS code for a function body. It returns the code and the variables that are
   declared in that code. These variables can be used to determine the amount of stack space to
   allocate.

   This function is expressed as a reduction over the code using tac->mips."
  [code]
  (reduce tac->mips {:vars {} :mips []} code))

(defn generate-function
  "Generates MIPS code for a particular function"
  [{:keys [function-name code]}]
  (let [function-name (protected-name function-name)
        {:keys [vars mips]} (handle-function-code code)]
    (str
      (function-prologue function-name (count vars))
      (join \newline mips)
      "\n"
      (function-epilogue function-name))))

;;; User facing functions
(defn generate-mips
  "Given a collection of functions that have been translated into three address code, returns a
   colleciton of MIPs instructions that are equivalent"
  [functions]
  (for [function functions]
    (generate-function function)))

(comment
  (print (generate-function {:function-name "test-function"
                             :code [{:operation :label :destination "test1"}
                                    {:operation :label :destination "test2"}]})))
