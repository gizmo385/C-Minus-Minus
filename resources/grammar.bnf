(* A C grammar for instaparse *)

START = PROGRAM_ELEMENT*

<PROGRAM_ELEMENT>   = DECLARATION
                    | FUNCTION

(* Expression grammar *)
UNARY_EXPRESSION    = (minus EXPRESSION)
                    | (not EXPRESSION)

BINARY_EXPRESSION   = EXPRESSION plus EXPRESSION
                    | EXPRESSION minus EXPRESSION
                    | EXPRESSION and EXPRESSION
                    | EXPRESSION or EXPRESSION
                    | EXPRESSION multiply EXPRESSION
                    | EXPRESSION divide EXPRESSION
                    | EXPRESSION eq EXPRESSION
                    | EXPRESSION neq EXPRESSION
                    | EXPRESSION gte EXPRESSION
                    | EXPRESSION lte EXPRESSION
                    | EXPRESSION gt EXPRESSION
                    | EXPRESSION lt EXPRESSION

<EXPRESSION>    = UNARY_EXPRESSION
                | BINARY_EXPRESSION
                | FUNCTION_CALL
                | ARRAY_ACCESS
                | ID
                | left_paren EXPRESSION right_paren
                | INTEGER
                | FLOAT
                | STRING
                | CHAR_CONST

FUNCTION_CALL = ID left_paren EXPR_LIST right_paren
ARRAY_ACCESS  = ID left_square_bracket EXPRESSION right_square_bracket

<EXPR_LIST> = EXPRESSION?
            | EXPR_LIST <','> EXPRESSION

(* Statements *)
<STATEMENT> = IF
            | IF_ELSE
            | WHILE_LOOP
            | FOR_LOOP
            | RETURN
            | ASSIGNMENT semicolon
            | FUNCTION_CALL semicolon
            | semicolon

FOR_LOOP    = <'for'> left_paren ASSIGNMENT? semicolon EXPRESSION? semicolon ASSIGNMENT? right_paren STATEMENT
IF          = <'if'> left_paren EXPRESSION <right_paren> STATEMENT
IF_ELSE     = <'if'> left_paren EXPRESSION <right_paren> STATEMENT <'else'> STATEMENT
WHILE_LOOP  = <'while'> left_paren EXPRESSION <right_paren> STATEMENT
RETURN      = <'return'> EXPRESSION? semicolon
ASSIGNMENT  = ID <'='> EXPRESSION
            | ID left_square_bracket EXPRESSION right_square_bracket <'='> EXPRESSION

(* Functions and Function Declarations *)
<FUNCTION_SIGNATURE> = (TYPE | void) ID left_paren PARAMS right_paren
FUNCTION_DECL = extern? FUNCTION_SIGNATURE semicolon

FUNCTION = FUNCTION_SIGNATURE left_curly_bracket VARIABLE_DECLARATION* STATEMENT* right_curly_bracket

(* Variable Declarations *)
VARIABLE_DECLARATION = TYPE VARIABLE_ID (<','> VARIABLE_ID)* semicolon
VARIABLE_ID = ID ARRAY_SIZE?
<ARRAY_SIZE>  = <left_square_bracket> EXPRESSION <right_square_bracket>

<DECLARATION>   = VARIABLE_DECLARATION
                | FUNCTION_DECL

PARAMS = <void>
       | PARAM_LIST

<PARAM_LIST>  = PARAM
              | PARAM_LIST (<','> PARAM)?

PARAM = TYPE ID ARRAY_BRACKETS?

ARRAY_BRACKETS = left_square_bracket right_square_bracket

(* Parser atoms *)
TYPE        = 'int'
            | 'float'
            | 'char'

void        = <'void'>
extern      = <'extern'>

ID = #'[a-zA-Z][a-zA-Z0-9_]*'

STRING = #'\"([^\n\"]|\\n)*\"'
CHAR_CONST = #'\'([^\n\"]|\\n)\''

INTEGER = #'[0-9]+'
FLOAT = #'[0-9]+\.[0-9]+'

(* Arithmetic Expression Operators  *)
minus = <'-'>
plus = <'+'>
multiply = <'*'>
divide = <'/'>

(* Boolean operators *)
or  = <'||'>
and = <'&&'>
not = <'!'>

(* Comparison operators *)
lte = <'<='>
gte = <'>='>
gt  = <'>'>
lt  = <'<'>
eq  = <'=='>
neq = <'!='>

(* Brackets *)
<left_paren>            = <'('>
<right_paren>           = <')'>
<left_square_bracket>   = <'['>
<right_square_bracket>  = <']'>
<left_curly_bracket>    = <'{'>
<right_curly_bracket>   = <'}'>

(* Other tokens *)
<semicolon>             = <';'>
